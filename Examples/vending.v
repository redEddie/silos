/* 
 * FINITE STATE MACHINE
 *
 * This file is automatically generated on Sse Command "State Machine/Save"
 * DO NOT MODIFY this file - it will get overwritten.
 *
 * The graphic visualization for this finite state machine is located in the
 * finite state machine file "vending.fsm".
 *
 * The outputs of this machine are the names of the states
 * translated to Verilog syntax. These outputs are:
 * "S0 "
 * "S5 "
 * "S10 "
 * "S15 "
 *
 * To use this machine in a design, include this Verilog file from within a
 * verilog module, e.g.
 *
 * module myStateMachine(...);
 *
 *   declare transition expression variables here.
 *   declare clock here.
 *   declare asynchronous set/clear here.
 *
 * `include "vending.v" // This file.
 *
 *  reference machine outputs here.
 *
 * endmodule
 *
 * Please contact Simucad Support (support@simucad.com)
 * for all suggestions and improvments.
 *
 * Note 1: Unknown values on transition expressions will set
 *         both the "from" state and the "to" state to
 *         Unknown value at the clock edge as an aide to debugging.
 *
 * Note 2: An Unknown state value will propagate at the clock
 *         edge through active transitions to the next state
 *         as an aide in debugging.
 *
 *
 * General Notes:
 *
 */



// PLI call to register machine in design

`ifdef silos_fsm
// This PLI call is not needed during batch simulation nor synthesis
initial $fsm_register("vending.fsm");
`endif



// Declarations for each state variable

reg S0 ;
reg S5 ;
reg S10 ;
reg S15 ;

`ifdef silos_fsm
// Declarations for each transition state
// NOT TO BE SYNTHESIZED; FOR USE BY FSM GRAPHICS ONLY
reg hold_S15_to_S0 ;
reg hold_SET_to_S0 ;
reg hold_S0_to_S5 ;
reg hold_S5_to_S10 ;
reg hold_S0_to_S10 ;
reg hold_S10_to_S15_1 ;
reg hold_S5_to_S15 ;
reg hold_S10_to_S15_2 ;
`endif



// Transitions from state `S0`

wire S0_to_S5 = S0 & (coin == `nickel );
wire S0_to_S10 = S0 & (coin == `dime );
wire S0_default = S0 & ~((coin == `nickel ) | (coin == `dime ));

// Transitions from state `S5`

wire S5_to_S10 = S5 & (coin == `nickel );
wire S5_to_S15 = S5 & (coin == `dime );
wire S5_default = S5 & ~((coin == `nickel ) | (coin == `dime ));

// Transitions from state `S10`

wire S10_to_S15_1 = S10 & (coin == `nickel );
wire S10_to_S15_2 = S10 & (coin == `dime );
wire S10_default = S10 & ~((coin == `nickel ) | (coin == `dime ));

// Transitions from state `S15`

wire S15_to_S0 = S15 ;

// Transitions which SET

wire SET_to_S0 = reset ;



// Next state terms

wire S0_next = S15_to_S0 | SET_to_S0 | S0_default ;
wire S5_next = S0_to_S5 | S5_default ;
wire S10_next = S5_to_S10 | S0_to_S10 | S10_default ;
wire S15_next = S10_to_S15_1 | S5_to_S15 | S10_to_S15_2 ;



// Clock

wire FsmCLOCK = clock  ;



// Flip-Flop declarations and state changes on clock or set

always @(posedge FsmCLOCK  or posedge SET_to_S0 ) begin
  if (SET_to_S0 ) begin
    S0 <= 1'b1;
    S5 <= 1'b0;
    S10 <= 1'b0;
    S15 <= 1'b0;
`ifdef silos_fsm
    // NOT TO BE SYNTHESIZED; FOR USE BY FSM GRAPHICS ONLY
    hold_S15_to_S0 <= 1'b0;
    hold_SET_to_S0 <= SET_to_S0 ;
    hold_S0_to_S5 <= 1'b0;
    hold_S5_to_S10 <= 1'b0;
    hold_S0_to_S10 <= 1'b0;
    hold_S10_to_S15_1 <= 1'b0;
    hold_S5_to_S15 <= 1'b0;
    hold_S10_to_S15_2 <= 1'b0;
`endif
  end else begin
    S0 <= S0_next ;
    S5 <= S5_next ;
    S10 <= S10_next ;
    S15 <= S15_next ;
`ifdef silos_fsm
    // NOT TO BE SYNTHESIZED; FOR USE BY FSM GRAPHICS ONLY
    hold_S15_to_S0 <= S15_to_S0 ;
    hold_SET_to_S0 <= SET_to_S0 ;
    hold_S0_to_S5 <= S0_to_S5 ;
    hold_S5_to_S10 <= S5_to_S10 ;
    hold_S0_to_S10 <= S0_to_S10 ;
    hold_S10_to_S15_1 <= S10_to_S15_1 ;
    hold_S5_to_S15 <= S5_to_S15 ;
    hold_S10_to_S15_2 <= S10_to_S15_2 ;
`endif
  end
end

